/var/www/www-root/data/site/vdestor.ru/index_opensearch_v4.php
<?php
/**
 * 🚀 ИНДЕКСАТОР OPENSEARCH v5.0 - ТОЛЬКО СТАТИЧЕСКИЕ ДАННЫЕ
 * 
 * Индексирует только постоянную информацию о товарах:
 * - Основные данные (название, артикул, SKU)
 * - Бренды и серии
 * - Категории и атрибуты
 * - Изображения и документы
 * 
 * НЕ индексирует:
 * - Цены (загружаются динамически для каждого клиента)
 * - Остатки (загружаются динамически по городам/складам)
 */

require __DIR__ . '/../vendor/autoload.php';

use OpenSearch\ClientBuilder;
use App\Core\Database;
use App\Core\Config;

// 🔧 Конфигурация
const BATCH_SIZE = 1000;
const MEMORY_LIMIT = '4G'; // Уменьшили, так как не храним динамические данные
const MAX_EXECUTION_TIME = 3600;
const MAX_OLD_INDICES = 2;

class StaticProductIndexer {
    private $client;
    private $pdo;
    private $processed = 0;
    private $errors = 0;
    private $startTime;
    private $newIndexName;
    private $totalProducts = 0;

    public function __construct() {
        $this->startTime = microtime(true);
        $this->newIndexName = 'products_' . date('Y_m_d_H_i_s');
        
        ini_set('memory_limit', MEMORY_LIMIT);
        ini_set('max_execution_time', MAX_EXECUTION_TIME);
        set_time_limit(0);
        
        echo $this->getHeader();
    }

    /**
     * 🎯 Главный метод запуска
     */
    public function run(): void {
        try {
            $this->initializeConnections();
            $this->analyzeCurrentState();
            $this->createNewIndex();
            $this->indexAllProducts();
            $this->switchAlias();
            $this->cleanupOldIndices();
            $this->showFinalReport();
        } catch (Throwable $e) {
            $this->handleError($e);
        }
    }
    
    private function getTotalStock(int $productId): int {
        $stmt = $this->pdo->prepare("
            SELECT COALESCE(SUM(quantity - reserved), 0) 
            FROM stock_balances 
            WHERE product_id = ? AND quantity > reserved
        ");
        $stmt->execute([$productId]);
        return (int)$stmt->fetchColumn();
    }
    
    private function getCitiesWithStock(int $productId): array {
        $stmt = $this->pdo->prepare("
            SELECT DISTINCT c.city_id
            FROM stock_balances sb
            JOIN city_warehouse_mapping cwm ON sb.warehouse_id = cwm.warehouse_id
            JOIN cities c ON cwm.city_id = c.city_id
            WHERE sb.product_id = ? AND sb.quantity > sb.reserved
        ");
        $stmt->execute([$productId]);
        return $stmt->fetchAll(PDO::FETCH_COLUMN);
    }
    
    private function hasAnyStock(int $productId): bool {
        $total = $this->getTotalStock($productId);
        return $total > 0;
    }
    
    

    /**
     * 🔌 Инициализация соединений
     */
    private function initializeConnections(): void {
        echo "🔌 === ИНИЦИАЛИЗАЦИЯ ===\n\n";
        
        // OpenSearch
        try {
            $this->client = ClientBuilder::create()
                ->setHosts(['localhost:9200'])
                ->setRetries(3)
                ->build();
                
            $info = $this->client->info();
            echo "✅ OpenSearch подключен: v" . $info['version']['number'] . "\n";
            
            $health = $this->client->cluster()->health();
            echo "📊 Статус кластера: {$health['status']}\n";
            
        } catch (Exception $e) {
            throw new Exception("❌ Ошибка OpenSearch: " . $e->getMessage());
        }

        // База данных
        try {
            $this->pdo = Database::getConnection();
            echo "✅ База данных подключена\n\n";
        } catch (Exception $e) {
            throw new Exception("❌ Ошибка БД: " . $e->getMessage());
        }
    }

    /**
     * 📊 Анализ текущего состояния
     */
    private function analyzeCurrentState(): void {
        echo "📊 === АНАЛИЗ ===\n\n";
        
        // Подсчет товаров
        $this->totalProducts = $this->pdo->query("SELECT COUNT(*) FROM products")->fetchColumn();
        echo "📦 Товаров в БД: {$this->totalProducts}\n";
        
        // Проверка связанных данных
        $brands = $this->pdo->query("SELECT COUNT(DISTINCT brand_id) FROM products WHERE brand_id IS NOT NULL")->fetchColumn();
        $series = $this->pdo->query("SELECT COUNT(DISTINCT series_id) FROM products WHERE series_id IS NOT NULL")->fetchColumn();
        $categories = $this->pdo->query("SELECT COUNT(*) FROM product_categories")->fetchColumn();
        $images = $this->pdo->query("SELECT COUNT(DISTINCT product_id) FROM product_images")->fetchColumn();
        
        echo "🏷️ Брендов используется: $brands\n";
        echo "📚 Серий используется: $series\n";
        echo "📁 Связей с категориями: $categories\n";
        echo "🖼️ Товаров с изображениями: $images\n\n";
    }

    /**
     * 📝 Создание нового индекса
     */
    private function createNewIndex(): void {
        echo "📝 === СОЗДАНИЕ ИНДЕКСА ===\n\n";
        echo "🆕 Имя индекса: {$this->newIndexName}\n";
        
        // Загружаем конфигурацию
        $configFile = __DIR__ . '/opensearch_mappings/products_v5.json';
        if (!file_exists($configFile)) {
            // Если нет файла, используем встроенную конфигурацию
            $config = $this->getIndexConfiguration();
            file_put_contents($configFile, json_encode($config, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE));
            echo "📄 Создан файл конфигурации: $configFile\n";
        } else {
            $config = json_decode(file_get_contents($configFile), true);
        }
        
        // Создаем индекс
        try {
            $this->client->indices()->create([
                'index' => $this->newIndexName,
                'body' => $config
            ]);
            echo "✅ Индекс создан\n\n";
        } catch (Exception $e) {
            throw new Exception("❌ Ошибка создания индекса: " . $e->getMessage());
        }
    }

    /**
     * 📦 Индексация всех товаров
     */
    private function indexAllProducts(): void {
        echo "📦 === ИНДЕКСАЦИЯ ===\n\n";
        echo "🔄 Начинаем индексацию {$this->totalProducts} товаров...\n";
        echo "📊 Размер пакета: " . BATCH_SIZE . "\n\n";
        
        $offset = 0;
        $progressBar = $this->initProgressBar();
        
        while ($offset < $this->totalProducts) {
            $products = $this->fetchProductBatch($offset);
            if (empty($products)) break;
            
            $this->indexBatch($products);
            
            $offset += BATCH_SIZE;
            $this->updateProgress($offset);
            
            // Управление памятью
            if ($offset % 10000 === 0) {
                gc_collect_cycles();
            }
        }
        
        echo "\n✅ Индексация завершена!\n\n";
    }

    /**
     * 📥 Получение пакета товаров
     */
    private function fetchProductBatch(int $offset): array {
        $sql = "
            SELECT 
                p.product_id,
                p.external_id,
                p.sku,
                p.name,
                p.description,
                p.unit,
                p.min_sale,
                p.weight,
                p.dimensions,
                p.created_at,
                p.updated_at,
                p.brand_id,
                p.series_id,
                b.name as brand_name,
                s.name as series_name
            FROM products p
            LEFT JOIN brands b ON p.brand_id = b.brand_id
            LEFT JOIN series s ON p.series_id = s.series_id
            ORDER BY p.product_id
            LIMIT :limit OFFSET :offset
        ";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->bindValue(':limit', BATCH_SIZE, PDO::PARAM_INT);
        $stmt->bindValue(':offset', $offset, PDO::PARAM_INT);
        $stmt->execute();
        
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * 📤 Индексация пакета
     */
    private function indexBatch(array $products): void {
        $bulkData = [];
        
        foreach ($products as $product) {
            // Получаем дополнительные данные
            $product['categories'] = $this->getProductCategories($product['product_id']);
            $product['images'] = $this->getProductImages($product['product_id']);
            $product['attributes'] = $this->getProductAttributes($product['product_id']);
            $product['documents'] = $this->getProductDocuments($product['product_id']);
            
            // Подготавливаем документ для индексации
            $doc = $this->prepareDocument($product);
            
            // Добавляем в bulk
            $bulkData[] = ['index' => ['_index' => $this->newIndexName, '_id' => $product['product_id']]];
            $bulkData[] = $doc;
        }
        
        // Отправляем в OpenSearch
        if (!empty($bulkData)) {
            try {
                $response = $this->client->bulk(['body' => $bulkData]);
                $this->processed += count($products);
                
                if ($response['errors']) {
                    $this->handleBulkErrors($response['items']);
                }
            } catch (Exception $e) {
                $this->errors += count($products);
                error_log("Bulk error: " . $e->getMessage());
            }
        }
    }

    /**
     * 🔨 Подготовка документа для индексации
     */
    private function prepareDocument(array $product): array {
        // Базовые поля
        $doc = [
            'product_id' => (int)$product['product_id'],
            'external_id' => $this->normalizeText($product['external_id']),
            'sku' => $this->normalizeText($product['sku']),
            'name' => $this->normalizeText($product['name']),
            'description' => $this->normalizeText($product['description']),
            'unit' => $product['unit'] ?: 'шт',
            'min_sale' => (int)($product['min_sale'] ?: 1),
            'weight' => (float)($product['weight'] ?: 0),
            'dimensions' => $product['dimensions'],
            'created_at' => $this->formatDate($product['created_at']),
            'updated_at' => $this->formatDate($product['updated_at']),
            
            // Бренд и серия
            'brand_id' => (int)($product['brand_id'] ?: 0),
            'brand_name' => $this->normalizeText($product['brand_name']),
            'series_id' => (int)($product['series_id'] ?: 0),
            'series_name' => $this->normalizeText($product['series_name']),
            
            // Дополнительные данные
            'categories' => $product['categories']['names'] ?? [],
            'category_ids' => $product['categories']['ids'] ?? [],
            'images' => $product['images'],
            'attributes' => $product['attributes'],
            'documents' => $product['documents'],
            
            // Поля для поиска
            'search_text' => $this->buildSearchText($product),
            
            // Данные для автодополнения
            'suggest' => $this->buildSuggestData($product),
            
            // Метрики (если есть)
            'popularity_score' => $this->getPopularityScore($product['product_id']),
            'total_stock' => $this->getTotalStock($product['product_id']),
            'cities_available' => $this->getCitiesWithStock($product['product_id']),
            'has_stock' => $this->hasAnyStock($product['product_id']),
            
            // Флаги для фильтрации
            'has_images' => !empty($product['images']),
            'has_description' => !empty($product['description'])
        ];
    
        // Обработка числовых свойств
        $product['numeric_props'] = [];
        foreach ($product['attributes'] as $attr) {
            if (preg_match('/^[\d\.,]+/', $attr['value'])) {
                $product['numeric_props'][] = [
                    'name' => $attr['name'],
                    'value' => (float) str_replace(',', '.', $attr['value'])
                ];
            }
        }
    
        // Добавляем числовые свойства в документ
        if (!empty($product['numeric_props'])) {
            $doc['numeric_props'] = $product['numeric_props'];
        }
    
        // Удаляем пустые значения
        return array_filter($doc, function($value) {
            return $value !== null && $value !== '' && $value !== [];
        });
    }

    /**
     * 📁 Получение категорий товара
     */
    private function getProductCategories(int $productId): array {
        $stmt = $this->pdo->prepare("
            SELECT c.category_id, c.name
            FROM product_categories pc
            JOIN categories c ON pc.category_id = c.category_id
            WHERE pc.product_id = ?
        ");
        $stmt->execute([$productId]);
        
        $ids = [];
        $names = [];
        
        while ($row = $stmt->fetch()) {
            $ids[] = (int)$row['category_id'];
            $names[] = $row['name'];
        }
        
        return ['ids' => $ids, 'names' => $names];
    }

    /**
     * 🖼️ Получение изображений товара
     */
    private function getProductImages(int $productId): array {
        $stmt = $this->pdo->prepare("
            SELECT url, alt_text, is_main
            FROM product_images
            WHERE product_id = ?
            ORDER BY is_main DESC, sort_order ASC
        ");
        $stmt->execute([$productId]);
        
        $images = [];
        while ($row = $stmt->fetch()) {
            $images[] = $row['url'];
        }
        
        return $images;
    }

    /**
     * 📋 Получение атрибутов товара
     */
    private function getProductAttributes(int $productId): array {
        $stmt = $this->pdo->prepare("
            SELECT name, value, unit
            FROM product_attributes
            WHERE product_id = ?
            ORDER BY sort_order
        ");
        $stmt->execute([$productId]);
        
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * 📄 Получение документов товара
     */
    private function getProductDocuments(int $productId): array {
        $stmt = $this->pdo->prepare("
            SELECT type, COUNT(*) as count
            FROM product_documents
            WHERE product_id = ?
            GROUP BY type
        ");
        $stmt->execute([$productId]);
        
        $docs = [
            'certificates' => 0,
            'manuals' => 0,
            'drawings' => 0
        ];
        
        while ($row = $stmt->fetch()) {
            $type = $row['type'] . 's'; // certificate -> certificates
            $docs[$type] = (int)$row['count'];
        }
        
        return $docs;
    }

    /**
     * 📈 Получение популярности товара
     */
    private function getPopularityScore(int $productId): float {
        $stmt = $this->pdo->prepare("
            SELECT popularity_score
            FROM product_metrics
            WHERE product_id = ?
        ");
        $stmt->execute([$productId]);
        
        $score = $stmt->fetchColumn();
        return $score !== false ? (float)$score : 0.0;
    }

    /**
     * 🔤 Построение текста для поиска
     */
    private function buildSearchText(array $product): string {
        $parts = [
            $product['name'],
            $product['external_id'],
            $product['sku'],
            $product['brand_name'],
            $product['series_name'],
            $product['description']
        ];
        
        // Добавляем категории
        if (!empty($product['categories']['names'])) {
            $parts = array_merge($parts, $product['categories']['names']);
        }
        
        // Добавляем значения атрибутов
        if (!empty($product['attributes'])) {
            foreach ($product['attributes'] as $attr) {
                $parts[] = $attr['value'];
            }
        }
        
        // Объединяем и нормализуем
        $text = implode(' ', array_filter($parts));
        return $this->normalizeText($text);
    }

    /**
     * 💡 Построение данных для автодополнения
     */
    private function buildSuggestData(array $product): array {
        $suggestions = [];
        
        // Название с высоким приоритетом
        if (!empty($product['name'])) {
            $suggestions[] = [
                'input' => [$product['name']],
                'weight' => 100
            ];
        }
        
        // Артикул
        if (!empty($product['external_id'])) {
            $suggestions[] = [
                'input' => [$product['external_id']],
                'weight' => 95
            ];
        }
        
        // SKU
        if (!empty($product['sku'])) {
            $suggestions[] = [
                'input' => [$product['sku']],
                'weight' => 90
            ];
        }
        
        // Бренд
        if (!empty($product['brand_name'])) {
            $suggestions[] = [
                'input' => [$product['brand_name']],
                'weight' => 70
            ];
        }
        
        return $suggestions;
    }

    /**
     * 🔄 Переключение алиаса
     */
    private function switchAlias(): void {
        echo "🔄 === ПЕРЕКЛЮЧЕНИЕ АЛИАСА ===\n\n";
        
        try {
            $actions = [];
            
            // Проверяем существующие алиасы
            $hasExistingAlias = false;
            try {
                $aliases = $this->client->indices()->getAlias(['name' => 'products_current']);
                if (!empty($aliases)) {
                    $hasExistingAlias = true;
                    echo "📋 Найдены существующие алиасы:\n";
                    foreach (array_keys($aliases) as $oldIndex) {
                        echo "   - $oldIndex\n";
                        $actions[] = ['remove' => ['index' => $oldIndex, 'alias' => 'products_current']];
                    }
                }
            } catch (\Exception $e) {
                // Алиас не существует - это нормально для первого запуска
                echo "ℹ️ Алиас products_current не существует (первый запуск)\n";
            }
            
            // Добавляем новый алиас
            $actions[] = ['add' => ['index' => $this->newIndexName, 'alias' => 'products_current']];
            
            // Выполняем все действия одной транзакцией
            $response = $this->client->indices()->updateAliases([
                'body' => ['actions' => $actions]
            ]);
            
            if ($response['acknowledged'] === true) {
                echo "✅ Алиас products_current успешно " . 
                     ($hasExistingAlias ? "переключен на" : "создан для") . 
                     " {$this->newIndexName}\n";
                
                // Проверяем результат
                sleep(1); // Даем время на применение изменений
                $checkAliases = $this->client->indices()->getAlias(['name' => 'products_current']);
                if (isset($checkAliases[$this->newIndexName])) {
                    echo "✅ Проверка: алиас корректно указывает на новый индекс\n";
                } else {
                    echo "⚠️ Предупреждение: алиас создан, но проверка не прошла\n";
                }
            } else {
                throw new \Exception("Не удалось создать/обновить алиас");
            }
            
        } catch (\Exception $e) {
            echo "❌ ОШИБКА при работе с алиасом: " . $e->getMessage() . "\n";
            echo "🔄 Попытка принудительного создания алиаса...\n";
            
            try {
                // Принудительное создание алиаса
                $this->client->indices()->putAlias([
                    'index' => $this->newIndexName,
                    'name' => 'products_current'
                ]);
                echo "✅ Алиас создан принудительно\n";
            } catch (\Exception $e2) {
                echo "❌ Критическая ошибка: " . $e2->getMessage() . "\n";
                throw $e2;
            }
        }
        
        echo "\n";
    }

    /**
     * 🧹 Очистка старых индексов
     */
    private function cleanupOldIndices(): void {
        echo "🧹 === ОЧИСТКА ===\n\n";
        
        try {
            $indices = $this->client->indices()->get(['index' => 'products_*']);
            $allIndices = array_keys($indices);
            
            // Сортируем по дате (новые первые)
            usort($allIndices, function($a, $b) {
                return strcmp($b, $a);
            });
            
            // Оставляем только нужное количество
            $toDelete = array_slice($allIndices, MAX_OLD_INDICES + 1);
            
            foreach ($toDelete as $index) {
                try {
                    $this->client->indices()->delete(['index' => $index]);
                    echo "🗑️ Удален старый индекс: $index\n";
                } catch (Exception $e) {
                    echo "⚠️ Не удалось удалить $index\n";
                }
            }
            
            if (empty($toDelete)) {
                echo "ℹ️ Старые индексы не требуют очистки\n";
            }
            
        } catch (Exception $e) {
            echo "⚠️ Ошибка при очистке: " . $e->getMessage() . "\n";
        }
        
        echo "\n";
    }

    /**
     * 🎉 Финальный отчет
     */
    private function showFinalReport(): void {
        $duration = microtime(true) - $this->startTime;
        $speed = $this->processed > 0 ? $this->processed / $duration : 0;
        
        echo "🎉 === ГОТОВО! ===\n\n";
        echo "✅ Обработано товаров: {$this->processed}\n";
        echo "❌ Ошибок: {$this->errors}\n";
        echo "⏱️ Время: " . $this->formatTime($duration) . "\n";
        echo "🚀 Скорость: " . round($speed) . " товаров/сек\n";
        echo "💾 Пиковая память: " . round(memory_get_peak_usage(true) / 1024 / 1024, 2) . " MB\n";
        echo "\n";
        echo "🔗 Индекс доступен по алиасу: products_current\n";
        echo "✅ Система готова к работе!\n\n";
    }

    // === Вспомогательные методы ===

    private function normalizeText(?string $text): string {
        if (empty($text)) return '';
        
        // Удаляем лишние пробелы и спецсимволы
        $text = preg_replace('/\s+/', ' ', $text);
        $text = trim($text);
        
        return $text;
    }

    private function formatDate(?string $date): string {
        if (empty($date)) return date('c');
        
        $timestamp = strtotime($date);
        return $timestamp ? date('c', $timestamp) : date('c');
    }

    private function formatTime(float $seconds): string {
        if ($seconds < 60) {
            return round($seconds, 1) . 's';
        } elseif ($seconds < 3600) {
            return floor($seconds / 60) . 'm ' . round($seconds % 60) . 's';
        } else {
            return floor($seconds / 3600) . 'h ' . floor(($seconds % 3600) / 60) . 'm';
        }
    }

    private function updateProgress(int $current): void {
        $percent = round(($current / $this->totalProducts) * 100, 1);
        $bar = str_repeat('█', (int)($percent / 2)) . str_repeat('░', 50 - (int)($percent / 2));
        echo "\r[$bar] $percent% ({$this->processed}/{$this->totalProducts})";
    }

    private function initProgressBar(): void {
        echo "Progress: ";
    }

    private function handleBulkErrors(array $items): void {
        foreach ($items as $item) {
            if (isset($item['index']['error'])) {
                $this->errors++;
                error_log("Index error for ID {$item['index']['_id']}: " . json_encode($item['index']['error']));
            }
        }
    }

    private function handleError(Throwable $e): void {
        echo "\n\n💥 КРИТИЧЕСКАЯ ОШИБКА\n";
        echo "❌ " . $e->getMessage() . "\n";
        echo "📍 " . $e->getFile() . ":" . $e->getLine() . "\n\n";
        
        // Пытаемся удалить частично созданный индекс
        if (!empty($this->newIndexName)) {
            try {
                $this->client->indices()->delete(['index' => $this->newIndexName]);
                echo "🧹 Частично созданный индекс удален\n";
            } catch (Exception $cleanupError) {
                // Игнорируем
            }
        }
        
        exit(1);
    }

    private function getHeader(): string {
        return "
================================================================================
🚀 ИНДЕКСАТОР СТАТИЧЕСКИХ ДАННЫХ OPENSEARCH v5.0
================================================================================
📅 " . date('Y-m-d H:i:s') . "
🖥️ " . gethostname() . "
🐘 PHP " . PHP_VERSION . "
💾 Memory limit: " . ini_get('memory_limit') . "
================================================================================

";
    }

    /**
     * 📄 Конфигурация индекса (упрощенная для статических данных)
     */
    private function getIndexConfiguration(): array {
        return [
            'settings' => [
                'number_of_shards' => 2, // Для миллиона товаров лучше 2 шарда
                'number_of_replicas' => 1,
                'index.max_ngram_diff' => 20,
                'index.max_result_window' => 50000,
                'index.refresh_interval' => '30s',
                
                'analysis' => [
                    'normalizer' => [
                        'lowercase' => [
                            'type' => 'custom',
                            'char_filter' => [],
                            'filter' => ['lowercase']
                        ]
                    ],
                    
                    'char_filter' => [
                        // 🔥 ГЛАВНОЕ ИСПРАВЛЕНИЕ: добавляем маппинг клавиатуры
                        'ru_en_keyboard_mapping' => [
                            'type' => 'mapping',
                            'mappings' => [
                                'q=>й', 'w=>ц', 'e=>у', 'r=>к', 't=>е', 'y=>н', 'u=>г', 'i=>ш', 'o=>щ', 'p=>з',
                                'a=>ф', 's=>ы', 'd=>в', 'f=>а', 'g=>п', 'h=>р', 'j=>о', 'k=>л', 'l=>д',
                                'z=>я', 'x=>ч', 'c=>с', 'v=>м', 'b=>и', 'n=>т', 'm=>ь',
                                // И обратные маппинги
                                'й=>q', 'ц=>w', 'у=>e', 'к=>r', 'е=>t', 'н=>y', 'г=>u', 'ш=>i', 'щ=>o', 'з=>p',
                                'ф=>a', 'ы=>s', 'в=>d', 'а=>f', 'п=>g', 'р=>h', 'о=>j', 'л=>k', 'д=>l',
                                'я=>z', 'ч=>x', 'с=>c', 'м=>v', 'и=>b', 'т=>n', 'ь=>m'
                            ]
                        ],
                        
                        'code_normalizer' => [
                            'type' => 'pattern_replace',
                            'pattern' => '[\\s\\-\\._/,()]+',
                            'replacement' => ''
                        ],
                        
                        // Склеиваем числа с единицами: "16 А" -> "16А"
                        'unit_normalizer' => [
                            'type' => 'pattern_replace',
                            'pattern' => '(\\d+)\\s+([а-яА-ЯA-Za-z]{1,3})\\b',
                            'replacement' => '$1$2'
                        ],
                        
                        'space_normalizer' => [
                            'type' => 'pattern_replace',
                            'pattern' => '\\s+',
                            'replacement' => ' '
                        ]
                    ],
                    
                    'tokenizer' => [
                        'edge_ngram_tokenizer' => [
                            'type' => 'edge_ngram',
                            'min_gram' => 2,
                            'max_gram' => 15,
                            'token_chars' => ['letter', 'digit']
                        ]
                    ],
                    
                    'filter' => [
                        'synonym_filter' => [
                            'type' => 'synonym',
                            'synonyms' => [
                                'выключатель,переключатель,switch,свитч,выкл,выключ',
                                'розетка,разъем,socket,гнездо,разьем,розет',
                                'кабель,провод,шнур,cable,wire,кабел,кабл',
                                'автомат,автоматический выключатель,авт выкл,mcb,автомат выключатель',
                                'щит,щиток,шкаф,бокс,panel,щитовое',
                                'лампа,лампочка,светильник,lamp,light,освещение',
                                // Бренды
                                'шнайдер,schneider,шнейдер,schneid=>schneider',
                                'легранд,legrand,легран=>legrand',
                                'иэк,iek,иек=>iek',
                                // Единицы измерения
                                'а,ампер,a,amp,ampere=>а',
                                'в,вольт,v,volt=>в',
                                'вт,ватт,w,watt=>вт',
                                'мм,миллиметр,mm=>мм'
                            ]
                        ],
                        'russian_stemmer' => [
                            'type' => 'stemmer',
                            'language' => 'russian'
                        ],
                        'edge_ngram_filter' => [
                            'type' => 'edge_ngram',
                            'min_gram' => 2,
                            'max_gram' => 15
                        ]
                    ],
                    
                    'analyzer' => [
                        // Для основного текста - с нормализацией клавиатуры
                        'text_analyzer' => [
                            'tokenizer' => 'standard',
                            'char_filter' => ['ru_en_keyboard_mapping', 'unit_normalizer', 'space_normalizer'],
                            'filter' => ['lowercase', 'synonym_filter', 'russian_stemmer']
                        ],
                        
                        // Для артикулов - точный поиск
                        'code_analyzer' => [
                            'tokenizer' => 'keyword',
                            'char_filter' => ['code_normalizer'],
                            'filter' => ['lowercase']
                        ],
                        
                        // Для автодополнения
                        'autocomplete_analyzer' => [
                            'tokenizer' => 'edge_ngram_tokenizer',
                            'char_filter' => ['ru_en_keyboard_mapping', 'space_normalizer'],
                            'filter' => ['lowercase']
                        ],
                        
                        // Для поиска - без стемминга, но с синонимами
                        'search_analyzer' => [
                            'tokenizer' => 'standard',
                            'char_filter' => ['ru_en_keyboard_mapping', 'unit_normalizer'],
                            'filter' => ['lowercase', 'synonym_filter']
                        ]
                    ]
                ]
            ],
            
            'mappings' => [
                'properties' => [
                    'product_id' => ['type' => 'long'],
                    
                    // 🔥 ИСПРАВЛЕННЫЙ маппинг для названия
                    'name' => [
                        'type' => 'text',
                        'analyzer' => 'text_analyzer',
                        'search_analyzer' => 'search_analyzer',
                        'fields' => [
                            'keyword' => ['type' => 'keyword'],
                            'autocomplete' => [
                                'type' => 'text',
                                'analyzer' => 'autocomplete_analyzer',
                                'search_analyzer' => 'search_analyzer'
                            ],
                            'exact' => [
                                'type' => 'text',
                                'analyzer' => 'keyword',
                                'normalizer' => 'lowercase'
                            ]
                        ]
                    ],
                    
                    // Артикул с поддержкой частичного поиска
                    'external_id' => [
                        'type' => 'text',
                        'analyzer' => 'code_analyzer',
                        'fields' => [
                            'keyword' => ['type' => 'keyword'],
                            'prefix' => [
                                'type' => 'text',
                                'analyzer' => 'autocomplete_analyzer'
                            ]
                        ]
                    ],
                    
                    'sku' => [
                        'type' => 'text',
                        'analyzer' => 'code_analyzer',
                        'fields' => [
                            'keyword' => ['type' => 'keyword'],
                            'prefix' => [
                                'type' => 'text',
                                'analyzer' => 'autocomplete_analyzer'
                            ]
                        ]
                    ],
                    
                    'description' => [
                        'type' => 'text',
                        'analyzer' => 'text_analyzer',
                        'search_analyzer' => 'search_analyzer'
                    ],
                    
                    'brand_name' => [
                        'type' => 'text',
                        'analyzer' => 'text_analyzer',
                        'search_analyzer' => 'search_analyzer',
                        'fields' => [
                            'keyword' => ['type' => 'keyword'],
                            'exact' => ['type' => 'keyword', 'normalizer' => 'lowercase']
                        ]
                    ],
                    
                    'search_text' => [
                        'type' => 'text',
                        'analyzer' => 'text_analyzer',
                        'search_analyzer' => 'search_analyzer'
                    ],
                    
                    // Остальные поля как у вас...
                    'unit' => ['type' => 'keyword'],
                    'min_sale' => ['type' => 'integer'],
                    'weight' => ['type' => 'float'],
                    'brand_id' => ['type' => 'integer'],
                    'series_id' => ['type' => 'integer'],
                    'series_name' => ['type' => 'text', 'analyzer' => 'text_analyzer'],
                    'categories' => ['type' => 'text', 'analyzer' => 'text_analyzer'],
                    'category_ids' => ['type' => 'integer'],
                    'images' => ['type' => 'keyword'],
                    'popularity_score' => ['type' => 'float'],
                    'total_stock' => ['type' => 'integer'],
                    'has_stock' => ['type' => 'boolean'],
                    'created_at' => ['type' => 'date'],
                    'updated_at' => ['type' => 'date'],
                    
                    'attributes' => [
                        'type' => 'nested',
                        'properties' => [
                            'name' => ['type' => 'keyword'],
                            'value' => [
                                'type' => 'text',
                                'analyzer' => 'text_analyzer',
                                'fields' => ['keyword' => ['type' => 'keyword']]
                            ],
                            'unit' => ['type' => 'keyword']
                        ]
                    ],
                    
                    'suggest' => [
                        'type' => 'completion',
                        'analyzer' => 'autocomplete_analyzer',
                        'search_analyzer' => 'search_analyzer',
                        'max_input_length' => 50
                    ]
                ]
            ]
        ];
    }
}

// 🚀 ЗАПУСК
try {
    $indexer = new StaticProductIndexer();
    $indexer->run();
    exit(0);
} catch (Exception $e) {
    echo "\n💥 ФАТАЛЬНАЯ ОШИБКА: " . $e->getMessage() . "\n";
    exit(1);
}

/var/www/www-root/data/site/vdestor.ru/opensearch_mappings/products_v5.json
{
  "settings": {
    "number_of_shards": 1,
    "number_of_replicas": 1,
    "index.max_ngram_diff": 20,
    "index.max_result_window": 50000,
    "index.refresh_interval": "30s",
    "index.number_of_routing_shards": 1,
    "analysis": {
      "normalizer": {
        "lowercase": {
          "type": "custom",
          "char_filter": [],
          "filter": ["lowercase"]
        }
      },
      "char_filter": {
        "ru_en_keyboard_mapping": {
          "type": "mapping",
          "mappings": [
            "q=>й","w=>ц","e=>у","r=>к","t=>е","y=>н","u=>г","i=>ш","o=>щ","z=>з","p=>п",
            "a=>ф","s=>ы","d=>в","f=>а","g=>п","h=>р","j=>о","k=>л","l=>д",
            "x=>ч","c=>с","v=>м","b=>и","n=>т","m=>ь",
            "ё=>е","й=>и",
            "A=>А","B=>В","E=>Е","K=>К","M=>М","H=>Н","O=>О","P=>Р","C=>С","T=>Т","Y=>У","X=>Х",
            "/=> ","\\\\=> ","-=> ","_=> ",".=> ",",=> "
          ]
        },
        "code_normalizer": {
          "type": "pattern_replace",
          "pattern": "[\\s\\-\\._/,]+",
          "replacement": ""
        },
        "space_normalizer": {
          "type": "pattern_replace",
          "pattern": "\\s+",
          "replacement": " "
        },
        "remove_special": {
          "type": "pattern_replace",
          "pattern": "[^\\p{L}\\p{N}\\s]",
          "replacement": " "
        }
      },
      "tokenizer": {
        "edge_ngram_tokenizer": {
          "type": "edge_ngram",
          "min_gram": 1,
          "max_gram": 20,
          "token_chars": ["letter", "digit"]
        },
        "ngram_tokenizer": {
          "type": "ngram",
          "min_gram": 3,
          "max_gram": 5,
          "token_chars": ["letter", "digit"]
        },
        "autocomplete_tokenizer": {
          "type": "edge_ngram",
          "min_gram": 2,
          "max_gram": 15,
          "token_chars": ["letter", "digit"]
        }
      },
      "filter": {
        "synonym_filter": {
          "type": "synonym",
          "synonyms": [
            "выключатель,переключатель,switch,свитч,выкл,выключ",
            "розетка,разъем,socket,гнездо,разьем,розет",
            "кабель,провод,шнур,cable,wire,кабел,кабл",
            "автомат,автоматический выключатель,авт выкл,mcb,автомат выключатель,автоматич",
            "щит,щиток,шкаф,бокс,panel,щитовое,щитов",
            "лампа,лампочка,светильник,lamp,light,освещение,ламп",
            "вт,ватт,w,watt=>ватт",
            "квт,киловатт,kw,kilowatt=>киловатт",
            "а,ампер,a,amp,ampere=>ампер",
            "в,вольт,v,volt=>вольт",
            "мм,миллиметр,mm=>миллиметр",
            "м,метр,m,meter=>метр",
            "шнайдер,schneider,шнейдер,schneid=>schneider",
            "легранд,legrand,легран=>legrand",
            "абб,abb=>abb",
            "иэк,iek,иек=>iek",
            "дкс,dks,дкц=>dks"
          ]
        },
        "russian_stemmer": {
          "type": "stemmer",
          "language": "russian"
        },
        "english_stemmer": {
          "type": "stemmer",
          "language": "english"
        },
        "shingle_filter": {
          "type": "shingle",
          "min_shingle_size": 2,
          "max_shingle_size": 3,
          "output_unigrams": true
        },
        "edge_ngram_filter": {
          "type": "edge_ngram",
          "min_gram": 2,
          "max_gram": 15
        },
        "phonetic_filter": {
          "type": "phonetic",
          "encoder": "double_metaphone",
          "replace": false
        }
      },
      "analyzer": {
        "text_analyzer": {
          "tokenizer": "standard",
          "char_filter": ["ru_en_keyboard_mapping", "space_normalizer"],
          "filter": ["lowercase", "synonym_filter", "russian_stemmer", "english_stemmer"]
        },
        "text_analyzer_no_stemming": {
          "tokenizer": "standard",
          "char_filter": ["ru_en_keyboard_mapping", "space_normalizer"],
          "filter": ["lowercase", "synonym_filter"]
        },
        "code_analyzer": {
          "tokenizer": "keyword",
          "char_filter": ["code_normalizer"],
          "filter": ["lowercase"]
        },
        "code_prefix_analyzer": {
          "tokenizer": "keyword",
          "char_filter": ["code_normalizer"],
          "filter": ["lowercase", "edge_ngram_filter"]
        },
        "autocomplete_analyzer": {
          "tokenizer": "autocomplete_tokenizer",
          "char_filter": ["ru_en_keyboard_mapping", "space_normalizer"],
          "filter": ["lowercase"]
        },
        "ngram_analyzer": {
          "tokenizer": "ngram_tokenizer",
          "char_filter": ["ru_en_keyboard_mapping", "remove_special"],
          "filter": ["lowercase"]
        },
        "phonetic_analyzer": {
          "tokenizer": "standard",
          "char_filter": ["space_normalizer"],
          "filter": ["lowercase", "phonetic_filter"]
        },
        "search_analyzer": {
          "tokenizer": "standard",
          "char_filter": ["ru_en_keyboard_mapping", "space_normalizer"],
          "filter": ["lowercase", "synonym_filter"]
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "product_id": {
        "type": "long",
        "index": true
      },
      "external_id": {
        "type": "text",
        "analyzer": "code_analyzer",
        "search_analyzer": "code_analyzer",
        "fields": {
          "keyword": {
            "type": "keyword",
            "normalizer": "lowercase"
          },
          "prefix": {
            "type": "text",
            "analyzer": "code_prefix_analyzer",
            "search_analyzer": "code_analyzer"
          },
          "ngram": {
            "type": "text",
            "analyzer": "ngram_analyzer"
          }
        }
      },
      "sku": {
        "type": "text",
        "analyzer": "code_analyzer",
        "search_analyzer": "code_analyzer",
        "fields": {
          "keyword": {
            "type": "keyword",
            "normalizer": "lowercase"
          },
          "prefix": {
            "type": "text",
            "analyzer": "code_prefix_analyzer",
            "search_analyzer": "code_analyzer"
          }
        }
      },
      "name": {
        "type": "text",
        "analyzer": "text_analyzer",
        "search_analyzer": "search_analyzer",
        "fields": {
          "keyword": {
            "type": "keyword"
          },
          "raw": {
            "type": "keyword",
            "normalizer": "lowercase"
          },
          "no_stemming": {
            "type": "text",
            "analyzer": "text_analyzer_no_stemming",
            "search_analyzer": "search_analyzer"
          },
          "autocomplete": {
            "type": "text",
            "analyzer": "autocomplete_analyzer",
            "search_analyzer": "search_analyzer"
          },
          "ngram": {
            "type": "text",
            "analyzer": "ngram_analyzer"
          },
          "phonetic": {
            "type": "text",
            "analyzer": "phonetic_analyzer"
          }
        }
      },
      "description": {
        "type": "text",
        "analyzer": "text_analyzer",
        "search_analyzer": "search_analyzer",
        "fields": {
          "ngram": {
            "type": "text",
            "analyzer": "ngram_analyzer"
          }
        }
      },
      "unit": {
        "type": "keyword"
      },
      "min_sale": {
        "type": "integer"
      },
      "weight": {
        "type": "float"
      },
      "dimensions": {
        "type": "keyword"
      },
      "created_at": {
        "type": "date"
      },
      "updated_at": {
        "type": "date"
      },
      "brand_id": {
        "type": "integer"
      },
      "brand_name": {
        "type": "text",
        "analyzer": "text_analyzer",
        "search_analyzer": "search_analyzer",
        "fields": {
          "keyword": {
            "type": "keyword"
          },
          "raw": {
            "type": "keyword",
            "normalizer": "lowercase"
          },
          "autocomplete": {
            "type": "text",
            "analyzer": "autocomplete_analyzer",
            "search_analyzer": "search_analyzer"
          },
          "phonetic": {
            "type": "text",
            "analyzer": "phonetic_analyzer"
          }
        }
      },
      "series_id": {
        "type": "integer"
      },
      "series_name": {
        "type": "text",
        "analyzer": "text_analyzer",
        "search_analyzer": "search_analyzer",
        "fields": {
          "keyword": {
            "type": "keyword"
          },
          "raw": {
            "type": "keyword",
            "normalizer": "lowercase"
          },
          "autocomplete": {
            "type": "text",
            "analyzer": "autocomplete_analyzer"
          }
        }
      },
      "price": {
        "type": "object",
        "properties": {
          "final": {
            "type": "float"
          },
          "base": {
            "type": "float"
          },
          "has_special": {
            "type": "boolean"
          }
        }
      },
      "stock": {
        "type": "object",
        "properties": {
          "quantity": {
            "type": "integer"
          },
          "available": {
            "type": "boolean"
          }
        }
      },
      "availability": {
        "type": "object",
        "properties": {
          "text": {
            "type": "text"
          }
        }
      },
      "images": {
        "type": "keyword"
      },
      "image_url": {
        "type": "keyword"
      },
      "image_urls": {
        "type": "keyword"
      },
      "_exact_match": {
        "type": "boolean"
      },
      "_formatted_name": {
        "type": "text"
      },
      "_highlight": {
        "type": "object",
        "properties": {
          "name": {
            "type": "text"
          }
        }
      },
      "suggest": {
        "type": "completion",
        "analyzer": "text_analyzer_no_stemming",
        "search_analyzer": "text_analyzer_no_stemming",
        "preserve_separators": false,
        "preserve_position_increments": false,
        "max_input_length": 100
      },
      "popularity_score": {
        "type": "float",
        "null_value": 0.0
      },
      "in_stock": {
        "type": "boolean",
        "null_value": false
      },
      "categories": {
        "type": "text",
        "analyzer": "text_analyzer",
        "fields": {
          "keyword": {
            "type": "keyword"
          },
          "raw": {
            "type": "keyword",
            "normalizer": "lowercase"
          }
        }
      },
      "category_ids": {
        "type": "integer"
      },
      "attributes": {
        "type": "nested",
        "properties": {
          "name": {
            "type": "text",
            "analyzer": "text_analyzer",
            "fields": {
              "keyword": {
                "type": "keyword"
              }
            }
          },
          "value": {
            "type": "text",
            "analyzer": "text_analyzer",
            "fields": {
              "keyword": {
                "type": "keyword"
              }
            }
          },
          "unit": {
            "type": "keyword"
          }
        }
      },
      "documents": {
        "type": "object",
        "properties": {
          "certificates": {
            "type": "integer"
          },
          "manuals": {
            "type": "integer"
          },
          "drawings": {
            "type": "integer"
          }
        }
      },
      "total_stock": {
        "type": "integer"
      },
      "cities_available": {
        "type": "integer"
      },
      "has_stock": {
        "type": "boolean"
      }
    }
  }
}

/var/www/www-root/data/site/vdestor.ru/src/Services/SearchService.php
<?php
namespace App\Services;

use App\Core\Database;
use App\Core\Logger;
use App\Core\Cache;
use OpenSearch\ClientBuilder;

class SearchService
{
    private static ?\OpenSearch\Client $client = null;

    public static function search(array $params): array
    {
        $requestId = uniqid('search_', true);
        $startTime = microtime(true);

        // ДОБАВЛЯЕМ ДИАГНОСТИКУ
        $diagnostics = [
            'request_id' => $requestId,
            'start_time' => date('Y-m-d H:i:s'),
            'params' => $params
        ];

        Logger::info("🔍 [$requestId] Search started", ['params' => $params]);

        try {
            $params = self::validateParams($params);
            $diagnostics['validated_params'] = $params;

            // Если нет поискового запроса, используем MySQL для листинга
            if (empty($params['q']) || strlen(trim($params['q'])) === 0) {
                Logger::info("📋 [$requestId] Empty query, using MySQL for listing");
                $diagnostics['search_method'] = 'mysql_listing';

                $result = self::searchViaMySQL($params);
                $result['diagnostics'] = $diagnostics;

                return [
                    'success' => true,
                    'data' => $result
                ];
            }

            // Парсим поисковый запрос
            $parsedQuery = self::parseSearchQuery($params['q']);
            $diagnostics['parsed_query'] = $parsedQuery;

            // Проверяем доступность OpenSearch
            $opensearchAvailable = self::isOpenSearchAvailable();
            $diagnostics['opensearch_available'] = $opensearchAvailable;

            if ($opensearchAvailable) {
                Logger::debug("✅ [$requestId] Using OpenSearch");
                $diagnostics['search_method'] = 'opensearch';

                try {
                    $result = self::performOpenSearchWithTimeout($params, $requestId, $parsedQuery);
                    $diagnostics['opensearch_success'] = true;
                    $result['diagnostics'] = $diagnostics;

                    $duration = round((microtime(true) - $startTime) * 1000, 2);
                    Logger::info("✅ [$requestId] OpenSearch completed in {$duration}ms");

                    return [
                        'success' => true,
                        'data' => $result
                    ];
                } catch (\Exception $e) {
                    Logger::warning("⚠️ [$requestId] OpenSearch failed, falling back to MySQL", [
                        'error' => $e->getMessage()
                    ]);
                    $diagnostics['opensearch_error'] = $e->getMessage();
                    $diagnostics['search_method'] = 'mysql_fallback';
                }
            } else {
                Logger::warning("⚠️ [$requestId] OpenSearch unavailable, using MySQL");
                $diagnostics['search_method'] = 'mysql_primary';
            }

            // MySQL поиск (основной или fallback)
            $result = self::searchViaMySQL($params);
            $result['diagnostics'] = $diagnostics;

            return [
                'success' => true,
                'data' => $result
            ];

        } catch (\Exception $e) {
            $duration = round((microtime(true) - $startTime) * 1000, 2);
            Logger::error("❌ [$requestId] Failed after {$duration}ms", [
                'error' => $e->getMessage()
            ]);

            $diagnostics['final_error'] = $e->getMessage();
            $diagnostics['search_method'] = 'error_fallback';

            // Всегда пробуем MySQL fallback при ошибке
            try {
                Logger::info("🔄 [$requestId] Trying MySQL fallback");
                $result = self::searchViaMySQL($params);
                $result['diagnostics'] = $diagnostics;

                return [
                    'success' => true,
                    'data' => $result,
                    'used_fallback' => true
                ];
            } catch (\Exception $fallbackError) {
                Logger::error("❌ [$requestId] MySQL fallback also failed", [
                    'error' => $fallbackError->getMessage()
                ]);

                $diagnostics['fallback_error'] = $fallbackError->getMessage();

                return [
                    'success' => false,
                    'error' => 'Search service temporarily unavailable',
                    'error_code' => 'SERVICE_UNAVAILABLE',
                    'data' => [
                        'products' => [],
                        'total' => 0,
                        'page' => $params['page'] ?? 1,
                        'limit' => $params['limit'] ?? 20,
                        'diagnostics' => $diagnostics
                    ]
                ];
            }
        }
    }

    /**
     * Улучшенный MySQL поиск с поддержкой транслитерации и исправления раскладки
     */
    private static function searchViaMySQL(array $params): array
    {
        $query = $params['q'] ?? '';
        $page = $params['page'];
        $limit = $params['limit'];
        $offset = ($page - 1) * $limit;
    
        try {
            $pdo = Database::getConnection();
    
            // Если нет поискового запроса - просто получаем список товаров
            if (empty($query)) {
                $sql = "SELECT SQL_CALC_FOUND_ROWS 
                        p.product_id, p.external_id, p.sku, p.name, p.description,
                        p.brand_id, p.series_id, p.unit, p.min_sale, p.weight, p.dimensions,
                        b.name as brand_name, s.name as series_name,
                        1 as relevance_score
                        FROM products p
                        LEFT JOIN brands b ON p.brand_id = b.brand_id
                        LEFT JOIN series s ON p.series_id = s.series_id
                        WHERE 1=1";
    
                $bindParams = [];
            } else {
                // Генерируем варианты запроса
                $searchVariants = self::generateSearchVariants($query);
    
                // Строим SQL с учетом всех вариантов
                $whereClauses = [];
                $bindParams = [];
                
                foreach ($searchVariants as $index => $variant) {
                    // Уникальные ключи для каждого варианта
                    $exactKey = "exact_v{$index}";
                    $prefixKey = "prefix_v{$index}";
                    $searchKey = "search_v{$index}";
    
                    $whereClauses[] = "(
                        p.external_id = :{$exactKey} OR
                        p.sku = :{$exactKey} OR
                        p.external_id LIKE :{$prefixKey} OR
                        p.sku LIKE :{$prefixKey} OR
                        p.name LIKE :{$searchKey} OR
                        p.description LIKE :{$searchKey} OR
                        b.name LIKE :{$searchKey}
                    )";
    
                    $bindParams[$exactKey] = $variant;
                    $bindParams[$prefixKey] = $variant . '%';
                    $bindParams[$searchKey] = '%' . $variant . '%';
                }
    
                // Базовый запрос с оригинальными параметрами для скоринга
                $sql = "SELECT SQL_CALC_FOUND_ROWS 
                        p.product_id, p.external_id, p.sku, p.name, p.description,
                        p.brand_id, p.series_id, p.unit, p.min_sale, p.weight, p.dimensions,
                        b.name as brand_name, s.name as series_name,
                        CASE 
                            WHEN p.external_id = :score_exact THEN 1000
                            WHEN p.sku = :score_exact THEN 900
                            WHEN p.external_id LIKE :score_prefix THEN 100
                            WHEN p.sku LIKE :score_prefix THEN 90
                            WHEN p.name = :score_exact THEN 80
                            WHEN p.name LIKE :score_prefix THEN 50
                            WHEN p.name LIKE :score_search THEN 30
                            ELSE 1
                        END as relevance_score
                        FROM products p
                        LEFT JOIN brands b ON p.brand_id = b.brand_id
                        LEFT JOIN series s ON p.series_id = s.series_id
                        WHERE (" . implode(' OR ', $whereClauses) . ")";
    
                // Добавляем параметры для скоринга (с уникальными именами)
                $bindParams['score_exact'] = $query;
                $bindParams['score_prefix'] = $query . '%';
                $bindParams['score_search'] = '%' . $query . '%';
            }
    
            // Сортировка
            switch ($params['sort']) {
                case 'name':
                    $sql .= " ORDER BY p.name ASC";
                    break;
                case 'external_id':
                    $sql .= " ORDER BY p.external_id ASC";
                    break;
                case 'popularity':
                    $sql .= " ORDER BY p.product_id DESC";
                    break;
                default:
                    if (!empty($query)) {
                        $sql .= " ORDER BY relevance_score DESC, p.name ASC";
                    } else {
                        $sql .= " ORDER BY p.product_id DESC";
                    }
                    break;
            }
    
            $sql .= " LIMIT :limit OFFSET :offset";
    
            $stmt = $pdo->prepare($sql);
    
            // Привязываем параметры поиска
            foreach ($bindParams as $key => $value) {
                $stmt->bindValue($key, $value, \PDO::PARAM_STR);
            }
    
            $stmt->bindValue(':limit', $limit, \PDO::PARAM_INT);
            $stmt->bindValue(':offset', $offset, \PDO::PARAM_INT);
            
            $stmt->execute();
    
            $products = $stmt->fetchAll(\PDO::FETCH_ASSOC);
            $total = $pdo->query("SELECT FOUND_ROWS()")->fetchColumn();
    
            Logger::info("MySQL search completed", [
                'query' => $query,
                'variants' => $searchVariants ?? [],
                'found' => count($products),
                'total' => $total
            ]);
    
            return [
                'products' => $products,
                'total' => (int)$total,
                'page' => $page,
                'limit' => $limit,
                'source' => 'mysql',
                'search_variants' => $searchVariants ?? []
            ];
    
        } catch (\Exception $e) {
            Logger::error('MySQL search failed', ['error' => $e->getMessage()]);
            throw $e;
        }
    }

    /**
     * Генерация вариантов поискового запроса
     */
    private static function generateSearchVariants(string $query): array
    {
        $variants = [$query]; // Оригинальный запрос

        // 1. Конвертация раскладки клавиатуры RU<->EN
        $layoutConverted = self::convertKeyboardLayout($query);
        if ($layoutConverted !== $query) {
            $variants[] = $layoutConverted;
        }

        // 2. Транслитерация RU->EN
        $transliterated = self::transliterate($query);
        if ($transliterated !== $query && $transliterated !== $layoutConverted) {
            $variants[] = $transliterated;
        }

        // 3. Обратная транслитерация EN->RU
        $cyrillic = self::toCyrillic($query);
        if ($cyrillic !== $query && !in_array($cyrillic, $variants)) {
            $variants[] = $cyrillic;
        }

        // 4. Удаление пробелов и спецсимволов для артикулов
        $normalized = preg_replace('/[^a-zA-Z0-9а-яА-Я]/u', '', $query);
        if ($normalized !== $query && !in_array($normalized, $variants)) {
            $variants[] = $normalized;
        }

        return array_unique($variants);
    }

    /**
     * Конвертация раскладки клавиатуры
     */
    private static function convertKeyboardLayout(string $text): string
    {
        $ru = 'йцукенгшщзхъфывапролджэячсмитьбю';
        $en = 'qwertyuiop[]asdfghjkl;\'zxcvbnm,.';

        $ruUpper = mb_strtoupper($ru);
        $enUpper = strtoupper($en);

        // RU -> EN
        $result = strtr($text, $ru . $ruUpper, $en . $enUpper);
        if ($result !== $text) {
            return $result;
        }

        // EN -> RU
        return strtr($text, $en . $enUpper, $ru . $ruUpper);
    }

    /**
     * Транслитерация RU -> EN
     */
    private static function transliterate(string $text): string
    {
        $rules = [
            'а' => 'a', 'б' => 'b', 'в' => 'v', 'г' => 'g', 'д' => 'd',
            'е' => 'e', 'ё' => 'e', 'ж' => 'zh', 'з' => 'z', 'и' => 'i',
            'й' => 'y', 'к' => 'k', 'л' => 'l', 'м' => 'm', 'н' => 'n',
            'о' => 'o', 'п' => 'p', 'р' => 'r', 'с' => 's', 'т' => 't',
            'у' => 'u', 'ф' => 'f', 'х' => 'h', 'ц' => 'ts', 'ч' => 'ch',
            'ш' => 'sh', 'щ' => 'sch', 'ъ' => '', 'ы' => 'y', 'ь' => '',
            'э' => 'e', 'ю' => 'yu', 'я' => 'ya'
        ];

        $text = mb_strtolower($text);
        return strtr($text, $rules);
    }

    /**
     * Обратная транслитерация EN -> RU (простая версия)
     */
    private static function toCyrillic(string $text): string
    {
        $rules = [
            'a' => 'а', 'b' => 'б', 'v' => 'в', 'g' => 'г', 'd' => 'д',
            'e' => 'е', 'z' => 'з', 'i' => 'и', 'k' => 'к', 'l' => 'л',
            'm' => 'м', 'n' => 'н', 'o' => 'о', 'p' => 'п', 'r' => 'р',
            's' => 'с', 't' => 'т', 'u' => 'у', 'f' => 'ф', 'h' => 'х',
            'c' => 'ц', 'y' => 'у'
        ];

        $text = strtolower($text);
        return strtr($text, $rules);
    }

    /**
     * Проверка доступности OpenSearch с кешированием
     */
    private static function isOpenSearchAvailable(): bool
    {
        static $isAvailable = null;
        static $lastCheck = 0;
        static $consecutiveFailures = 0;

        // Кеш проверки на 60 секунд при успехе, 10 секунд при неудаче
        $cacheTime = $isAvailable ? 60 : 10;

        if ($isAvailable !== null && (time() - $lastCheck) < $cacheTime) {
            return $isAvailable;
        }

        try {
            $startTime = microtime(true);
            $client = self::getClient();

            // Быстрая проверка ping
            $response = $client->ping();

            if ($response) {
                // Дополнительно проверяем здоровье кластера
                $health = $client->cluster()->health([
                    'timeout' => '2s'
                ]);

                $isAvailable = in_array($health['status'] ?? 'red', ['green', 'yellow']);

                if ($isAvailable) {
                    $consecutiveFailures = 0;
                    Logger::debug("✅ OpenSearch available", [
                        'ping_time_ms' => round((microtime(true) - $startTime) * 1000, 2),
                        'cluster_status' => $health['status'] ?? 'unknown'
                    ]);
                } else {
                    $consecutiveFailures++;
                    Logger::warning("⚠️ OpenSearch cluster not healthy", [
                        'status' => $health['status'] ?? 'unknown'
                    ]);
                }
            } else {
                $isAvailable = false;
                $consecutiveFailures++;
                Logger::warning("❌ OpenSearch ping failed");
            }

            $lastCheck = time();

        } catch (\Exception $e) {
            $isAvailable = false;
            $lastCheck = time();
            $consecutiveFailures++;

            Logger::error("❌ OpenSearch check failed", [
                'error' => $e->getMessage(),
                'consecutive_failures' => $consecutiveFailures
            ]);

            // После 5 неудачных попыток увеличиваем интервал проверки
            if ($consecutiveFailures >= 5) {
                $lastCheck = time() - 50; // Будет проверять раз в 10 секунд вместо каждого запроса
            }
        }

        return $isAvailable;
    }

    private static function getClient(): \OpenSearch\Client
    {
        if (self::$client === null) {
            self::$client = ClientBuilder::create()
                ->setHosts(['localhost:9200'])
                ->setRetries(1)
                ->setConnectionParams([
                    'timeout' => 5,
                    'connect_timeout' => 2
                ])
                ->build();
        }
        return self::$client;
    }

    private static function validateParams(array $params): array
    {
        return [
            'q' => trim($params['q'] ?? ''),
            'page' => max(1, (int)($params['page'] ?? 1)),
            'limit' => min(100, max(1, (int)($params['limit'] ?? 20))),
            'city_id' => (int)($params['city_id'] ?? 1),
            'sort' => $params['sort'] ?? 'relevance',
            'user_id' => $params['user_id'] ?? null
        ];
    }

    /**
     * 🔍 Умный парсер поискового запроса
     * 
     * Разбивает запрос на логические части:
     * - Числа с единицами (16А, 220В)
     * - Коды/артикулы (MVA40-1-016-C)
     * - Обычные слова (выключатель, автоматический)
     * 
     * @param string $query Поисковый запрос
     * @return array Структурированные части запроса
     */
    private static function parseSearchQuery(string $query): array
    {
        $query = trim($query);

        // Инициализируем результат
        $result = [
            'original' => $query,
            'words' => [],
            'numbers' => [],
            'codes' => [],
            'exact' => [],
            'cleaned' => ''
        ];

        if (empty($query)) {
            return $result;
        }

        // 1. Извлекаем точные фразы в кавычках
        if (preg_match_all('/"([^"]+)"/', $query, $matches)) {
            $result['exact'] = $matches[1];
            // Удаляем кавычки из основного запроса
            $query = preg_replace('/"[^"]+"/', '', $query);
        }

        // 2. Нормализуем запрос
        $normalized = preg_replace('/\s+/', ' ', trim($query));
        $result['cleaned'] = $normalized;

        // 3. Разбиваем на токены
        $tokens = preg_split('/[\s\-_,;.]+/', $normalized, -1, PREG_SPLIT_NO_EMPTY);

        foreach ($tokens as $token) {
            $token = trim($token);
            if (empty($token)) continue;

            // Проверяем, это число с единицами (16А, 220В, 2.5мм)
            if (preg_match('/^\d+([.,]\d+)?\s*[а-яА-Яa-zA-Z]*$/u', $token)) {
                $result['numbers'][] = $token;
            }
            // Проверяем, это код/артикул (содержит цифры, буквы, дефисы)
            elseif (preg_match('/^[a-zA-Z0-9\-_.]{3,}$/i', $token) && preg_match('/\d/', $token)) {
                $result['codes'][] = $token;
            }
            // Обычное слово
            else {
                $result['words'][] = $token;
            }
        }

        // 4. Убираем дубликаты
        $result['words'] = array_unique($result['words']);
        $result['numbers'] = array_unique($result['numbers']);
        $result['codes'] = array_unique($result['codes']);
        $result['exact'] = array_unique($result['exact']);

        return $result;
    }

    private const KNOWN_BRANDS = [
        'iek', 'karat', 'schneider', 'abb', 'legrand', 
        'русский свет', 'российский свет', 'russian light'
    ];

    /**
     * 🎨 Конфигурация подсветки найденных терминов в результатах поиска
     * 
     * Что это делает:
     * - Выделяет найденные слова в названии товара
     * - Подсвечивает совпадения в артикуле 
     * - Показывает релевантные части текста
     * 
     * @return array Конфигурация для OpenSearch highlight
     */
    private static function buildHighlightConfig(): array 
    {
        return [
            'fields' => [
                // Подсветка в названии товара (самое важное поле)
                'name' => [
                    'type' => 'unified',           
                    'number_of_fragments' => 0,   
                    'pre_tags' => ['<mark>'],     
                    'post_tags' => ['</mark>']    
                ],
                
                // Подсветка в артикуле (для точного поиска кодов)
                'external_id' => [
                    'type' => 'unified', 
                    'number_of_fragments' => 0,   
                    'pre_tags' => ['<mark>'],
                    'post_tags' => ['</mark>']
                ],
                
                // Подсветка в названии бренда
                'brand_name' => [
                    'type' => 'unified',
                    'number_of_fragments' => 0,
                    'pre_tags' => ['<mark>'],
                    'post_tags' => ['</mark>']
                ],
                
                // Подсветка в описании (если есть)
                'description' => [
                    'type' => 'unified',
                    'number_of_fragments' => 2,   
                    'fragment_size' => 150,       
                    'pre_tags' => ['<mark>'],
                    'post_tags' => ['</mark>']
                ]
            ],
            
            // Дополнительные настройки
            'require_field_match' => false,    
            'fragment_size' => 150,            
            'max_analyzer_offset' => 1000000   // ИСПРАВЛЕНО: правильное название поля
        ];
    }

    private static function performOpenSearchWithTimeout(array $params, string $requestId, array $parsedQuery): array
    {
        $client = self::getClient();
    
        // 🔥 Основная структура запроса
        $body = [
            'timeout' => '15s',
            'size' => $params['limit'],
            'from' => ($params['page'] - 1) * $params['limit'],
            'track_total_hits' => true,
            '_source' => true
        ];
    
        if (!empty($params['q'])) {
            $query = trim($params['q']);
            
            // Генерируем варианты запроса (включая конвертацию раскладки)
            $searchVariants = self::generateSearchVariants($query);
            
            // Создаем массив should условий для всех вариантов
            $shouldClauses = [];
            
            foreach ($searchVariants as $variantIndex => $variant) {
                // Для каждого варианта добавляем поиск
                
                // 1. Точное совпадение артикула/SKU
                $shouldClauses[] = [
                    'bool' => [
                        'should' => [
                            ['term' => ['external_id.keyword' => ['value' => $variant, 'boost' => 1000]]],
                            ['term' => ['sku.keyword' => ['value' => $variant, 'boost' => 900]]]
                        ]
                    ]
                ];
                
                // 2. Точная фраза в названии
                $shouldClauses[] = [
                    'match_phrase' => [
                        'name' => [
                            'query' => $variant,
                            'boost' => 500,
                            'slop' => 0
                        ]
                    ]
                ];
                
                // 3. Поиск в названии с анализатором
                $shouldClauses[] = [
                    'match' => [
                        'name' => [
                            'query' => $variant,
                            'operator' => 'and',
                            'boost' => 200,
                            'analyzer' => 'search_analyzer' // Используем анализатор с конвертацией раскладки
                        ]
                    ]
                ];
                
                // 4. Частичное совпадение
                $shouldClauses[] = [
                    'match' => [
                        'name' => [
                            'query' => $variant,
                            'minimum_should_match' => '75%',
                            'boost' => 100,
                            'analyzer' => 'search_analyzer'
                        ]
                    ]
                ];
                
                // 5. Поиск по бренду
                $shouldClauses[] = [
                    'match' => [
                        'brand_name' => [
                            'query' => $variant,
                            'boost' => 80,
                            'analyzer' => 'search_analyzer'
                        ]
                    ]
                ];
                
                // 6. Wildcard для артикулов
                if (strlen($variant) >= 3) {
                    $shouldClauses[] = [
                        'wildcard' => [
                            'external_id.keyword' => [
                                'value' => "*{$variant}*",
                                'boost' => 150
                            ]
                        ]
                    ];
                }
                
                // 7. Автодополнение
                $shouldClauses[] = [
                    'match' => [
                        'name.autocomplete' => [
                            'query' => $variant,
                            'boost' => 60
                        ]
                    ]
                ];
                
                // 8. Поиск в общем поисковом тексте
                $shouldClauses[] = [
                    'match' => [
                        'search_text' => [
                            'query' => $variant,
                            'boost' => 30,
                            'analyzer' => 'search_analyzer'
                        ]
                    ]
                ];
            }
    
            // Создаем базовый запрос
            $baseQuery = [
                'bool' => [
                    'should' => $shouldClauses,
                    'minimum_should_match' => 1
                ]
            ];
    
            // Добавляем функциональный скоринг
            $body['query'] = [
                'function_score' => [
                    'query' => $baseQuery,
                    'functions' => [
                        // Буст для товаров в наличии
                        [
                            'filter' => ['term' => ['has_stock' => true]],
                            'weight' => 1.5
                        ],
                        // Буст по популярности
                        [
                            'field_value_factor' => [
                                'field' => 'popularity_score',
                                'modifier' => 'log1p',
                                'factor' => 1.2,
                                'missing' => 0
                            ]
                        ]
                    ],
                    'score_mode' => 'multiply',
                    'boost_mode' => 'multiply'
                ]
            ];
    
            // ✅ Добавляем подсветку
            $body['highlight'] = self::buildHighlightConfig();
        } else {
            // Без поискового запроса - просто листинг
            $body['query'] = ['match_all' => new \stdClass()];
        }
    
        // Сортировка
        if (!empty($params['q'])) {
            $body['sort'] = [
                ['_score' => 'desc'],
                ['has_stock' => 'desc'],
                ['popularity_score' => 'desc']
            ];
        } else {
            switch ($params['sort']) {
                case 'name':
                    $body['sort'] = [['name.keyword' => 'asc']];
                    break;
                case 'external_id':
                    $body['sort'] = [['external_id.keyword' => 'asc']];
                    break;
                default:
                    $body['sort'] = [['product_id' => 'desc']];
                    break;
            }
        }
    
        Logger::debug("[$requestId] OpenSearch query", ['body' => json_encode($body, JSON_PRETTY_PRINT)]);
    
        try {
            $response = $client->search([
                'index' => 'products_current',
                'body' => $body
            ]);
    
            // Обработка результатов
            $products = [];
            foreach ($response['hits']['hits'] ?? [] as $hit) {
                $product = $hit['_source'];
                $product['_score'] = $hit['_score'] ?? 0;
    
                // Добавляем подсветку
                if (isset($hit['highlight'])) {
                    $product['_highlight'] = $hit['highlight'];
                }
    
                $products[] = $product;
            }
    
            $total = $response['hits']['total']['value'] ?? 0;
    
            Logger::info("[$requestId] OpenSearch success", [
                'query' => $params['q'],
                'total' => $total,
                'returned' => count($products),
                'max_score' => $response['hits']['max_score'] ?? 0,
                'variants_used' => $searchVariants ?? []
            ]);
    
            return [
                'products' => $products,
                'total' => $total,
                'page' => $params['page'],
                'limit' => $params['limit'],
                'source' => 'opensearch',
                'max_score' => $response['hits']['max_score'] ?? 0,
                'search_variants' => $searchVariants ?? []
            ];
    
        } catch (\Exception $e) {
            Logger::error("[$requestId] OpenSearch failed", ['error' => $e->getMessage()]);
            throw $e;
        }
    }
}
